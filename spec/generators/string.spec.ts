import { expect } from 'chai';

import { none } from '../../src/maybe';
import { Generators, Generator } from '../../src';

describe('string generators', () => {

  describe('concat', () => {

    it('should produce a string by concatenating the values generated by the given Generator', () => {
      const value = "abcde";
      const charGenerators = value.split("").map(char => Generators.pure(char));
      expect(Generators.concat(...charGenerators).generate().value).to.eql(value);
    });

    it('should produce the same generator if only one generator is given', () => {
      const generator = Generators.pure('a');
      expect(Generators.concat(generator).generate()).to.eql(generator.generate());
    });

    it('should produce empty string when no generators given', () => {
      expect(Generators.concat().generate().value).to.eql('');
    });
  });

  describe('repeat', () => {

    it('should produce a string by concatenating the values generated by the given Generator', () => {
      const value = 'a';
      const generator = Generators.pure(value);
      const times = 10;

      const expectedValue =   [...Array(times)].map(_ => value).join('');

      expect(Generators.repeat(times, generator).generate().value).to.eql(expectedValue);
    });

    it('should produce empty string if repeat is negative or 0', () => {
      const value = 'a';
      const generator = Generators.pure(value);
      expect(Generators.repeat(0, generator).generate().value).to.eql('');
      expect(Generators.repeat(-1, generator).generate().value).to.eql('');
    });

    it('should produce None if provided Generator generates None at least once', ()  => {
      const generator = Generators.sequenceOf(Generators.pure('a'), Generators.pure('b'), Generators.never());

      expect(Generators.repeat(3, generator).generate()).to.eql(none);
    });
  });

  describe('alphaNumString', () => {
    describeStringGenerator('alphaNumString - fixed length', Generators.alphaNumString(3), /[a-zA-Z0-9]{3}/);
    describeStringGenerator('alphaNumString - one symbol', Generators.alphaNumString(1), /[a-zA-Z0-9]/);
    describeStringGenerator('alphaNumString - empty string', Generators.alphaNumString(0), /.{0}/);
  });

  describe('hexString', () => {
    describeStringGenerator('hexString - fixed length', Generators.hexString(3), /[0-9A-F]{3}/);
    describeStringGenerator('hexString - one symbol', Generators.hexString(1), /[0-9A-F]/);
    describeStringGenerator('hexString - empty string', Generators.hexString(0), /.{0}/);
  });

  describeStringGenerator('asciiRange', Generators.asciiRange(40, 41), /[\(\)]/);
  describeStringGenerator('alphaLowerChar', Generators.alphaLowerChar(), /[a-z]/);
  describeStringGenerator('alphaUpperChar', Generators.alphaUpperChar(), /[A-Z]/);
  describeStringGenerator('alphaChar', Generators.alphaChar(), /[a-zA-Z]/);
  describeStringGenerator('numChar', Generators.numChar(), /[0-9]/);
  describeStringGenerator('alphaNumChar', Generators.alphaNumChar(), /[0-9a-zA-Z]/);
  describeStringGenerator('hexChar', Generators.hexChar(), /[0-9A-F]/);
  describeStringGenerator('uuid', Generators.uuid(), /[0-9A-F]{8}\-[0-9A-F]{4}\-4[0-9A-F]{3}\-[89AB][0-9A-F]{3}\-[0-9A-F]{12}/); // RFC 4122 compliant UUID

  describeStringGenerator('identifier', Generators.identifier(5), /[a-z][0-9a-zA-Z]{0,4}/, () => {

    it('should generate none if maxLength is zero', () => {
      expect(Generators.identifier(0).generate()).to.eql(none);
    });

    it('should generate a single character if maxLength is one', () => {
      expect(Generators.identifier(1).generate()).to.match(/[a-z]/);
    });
  });

  function describeStringGenerator(generatorName: string, generator: Generator<string>, expectedRegex: RegExp, moreSpecs: () => void = () => {}) {
    describe(generatorName, () => {
      const triesNumber = 10;

      const generatedCharacters = [...Array(triesNumber)].map(_ =>
        generator.generate()
      );
  
      it(`should generate strings matching ${expectedRegex}`, () => {
        expect(generatedCharacters.every(char => char.isDefined)).to.be.true;
        expect(generatedCharacters.every(char => expectedRegex.test(char.get()))).to.be.true;
      });
  
      it('should generate different strings', () => {
        const uniqueGeneratedCharacters = new Set(generatedCharacters);
        expect(uniqueGeneratedCharacters.size).to.be.above(1);
      });

      moreSpecs();
    });
  }
});